/*
 * generated by Xtext 2.29.0
 */
package edu.vanderbilt.isis.caid.assurancedsl.validation;

import org.checkerframework.checker.signature.qual.FullyQualifiedName;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

import com.google.common.collect.Iterables;
import com.google.inject.Inject;

import edu.vanderbilt.isis.caid.assurancedsl.assurance.UUIDType;
import edu.vanderbilt.isis.caid.assurancedsl.assurance.ALLNodes;
import edu.vanderbilt.isis.caid.assurancedsl.assurance.AssurancePackage;
import java.util.regex.*;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class AssuranceValidator extends AbstractAssuranceValidator {
    @Inject
    @Extension
    private IQualifiedNameProvider _iQualifiedNameProvider;
    public static final String INVALID_UUID = "invalidUUID";
    public static final String DUPLICATE_UUID = "duplicateUuid";
    public static final String DUPLICATE_FQN = "duplicateUuid";


    @Check(CheckType.NORMAL) // Run only at save
    public void checkUniqueUUIDs(UUIDType uuid) {
        // FIXME: This could end up being expensive
        // If perf. issues - consider moving to a global check over the entire resource-set and only run once from it.
        boolean hasDuplicate = false;
        for (Resource resource : uuid.eResource().getResourceSet().getResources()) {
            Iterable<UUIDType> uuidTypes = Iterables.<UUIDType>filter(
                    IteratorExtensions.<EObject>toIterable(resource.getAllContents()), UUIDType.class);

            for (UUIDType otherUuid : uuidTypes) {
                if (otherUuid != uuid && uuid.getInfo().equals(otherUuid.getInfo())) {
                    hasDuplicate = true;
                    break;
                }
            }

            if (hasDuplicate) {
                break;
            }
        }

        if (hasDuplicate) {
            error("Duplicate 'uuid' : '" + uuid.getInfo() + "' - remove duplicates, save, then run 'GSN: Assign UUIDs'",
                    AssurancePackage.Literals.UUID_TYPE__INFO,
                    DUPLICATE_UUID);
        }
    }

    // @Check(CheckType.NORMAL) // Run only at save
    // public void checkUniqueFQN(ALLNodes node) {
    //     boolean hasDuplicate = false;
    //     String thisFqn = this._iQualifiedNameProvider.getFullyQualifiedName(node).toString();

    //     for (Resource resource : node.eResource().getResourceSet().getResources()) {
    //         Iterable<ALLNodes> otherNodes = Iterables.<ALLNodes>filter(
    //                 IteratorExtensions.<EObject>toIterable(resource.getAllContents()), ALLNodes.class);

    //         for (ALLNodes otherNode : otherNodes) {
    //             if (otherNode == node) {
    //                 continue;
    //             }

    //             String otherFqn = this._iQualifiedNameProvider.getFullyQualifiedName(otherNode).toString();
    //             if (thisFqn.equals(otherFqn)) {
    //                 hasDuplicate = true;
    //                 break;
    //             }
    //         }

    //         if (hasDuplicate) {
    //             break;
    //         }
    //     }

    //     if (hasDuplicate) {
    //         error("Duplicate fully qualified name : '" + thisFqn + "' - rename duplicate.",
    //                 AssurancePackage.Literals.UUID_TYPE__INFO,
    //                 DUPLICATE_FQN);
    //     }
    // }

    @Check(CheckType.NORMAL) // Run only at save
    public void checkUUIDFormat(UUIDType uuid) {
        // FIXME: This could end up being expensive
        // If perf. issues - consider moving to a global check over the entire resource-set and only run once from it.
        boolean isValid = true;

        String regex
            = "^[{]?[0-9a-fA-F]{8}"
              + "-([0-9a-fA-F]{4}-)"
              + "{3}[0-9a-fA-F]{12}[}]?$";
 
        // Compile the ReGex
        Pattern p = Pattern.compile(regex);
 
        // If the string is empty
        // return false
        String str = uuid.getInfo();
        if (str == null) {
            isValid = false;
        }
 
        // Find match between given string
        // and regular expression
        // uSing Pattern.matcher()

        if (isValid)
        {
            Matcher m = p.matcher(str);
            isValid  = m.matches();

        }
 
        
        if (!isValid) {
            error("Invalid uuid : '" + uuid.getInfo() + "' - remove uuid, save, then run 'GSN: Assign UUIDs'",
                    AssurancePackage.Literals.UUID_TYPE__INFO,
                    INVALID_UUID);
        }
    }

}
